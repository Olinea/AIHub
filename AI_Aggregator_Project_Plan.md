# AI 聚合聊天平台——项目规划文档

## 1. 项目概述

### 1.1. 项目愿景

创建一个类似于 Poe 或 Chatbox 的 AI 服务聚合平台。用户可以通过本平台，使用统一的账号和积分（Token）系统，体验和调用来自不同顶尖提供商（如 OpenAI, Google, DeepSeek 等）的多种 AI 模型。本项目旨在为用户提供一个便捷、多样化的 AI 对话入口，同时为平台运营者提供一个可行的商业模式。

### 1.2. 目标用户

- 对多种 AI 模型感兴趣，希望在一个平台内对比体验的普通用户。
- 需要调用不同 AI 模型 API 来完成特定任务的开发者或内容创作者。
- 学习和研究 AI 技术的学生和爱好者。

---

## 2. 核心功能设计 (MVP - 最小可行产品)

### 2.1. 用户模块

- **用户注册**：通过邮箱/用户名和密码进行注册。
- **用户登录**：提供安全的登录认证机制。
- **用户中心**：
  - 显示用户信息。
  - 查看当前积分（Token）余额。
  - 查看积分消费历史。
  - (未来) 充值入口。

### 2.2. AI 对话模块

- **模型选择**：用户可以在对话界面清晰地看到当前可用的 AI 模型列表，并自由切换。
- **对话界面**：
  - 经典的聊天窗口布局。
  - 支持多轮对话，保留上下文。
  - 支持 Markdown 格式的响应渲染（如代码块、列表等）。
- **会话管理**：
  - 自动保存历史会话。
  - 用户可以创建新会话、切换或删除历史会話。

### 2.3. 计费与积分模块

- **积分系统**：用户的每次 AI 对话都将消耗一定数量的积分。
- **计费逻辑**：
  - 后端根据用户选择的模型和对话的长度（请求+响应的 token 数）进行计费。
  - 不同模型的单位价格不同。
  - 新用户注册时，可赠送一定的初始积分用于体验。

### 2.4. 后台管理模块 (简化版)

- **用户管理**：查看所有注册用户列表。
- **模型管理**：可以动态添加、编辑、禁用不同的 AI 模型及其 API Key 和计费单价。

---

## 3. 技术栈选型

根据您已有的 `Java + Vue3 + MySQL` 技术背景，推荐以下技术栈：

- **前端 (Frontend)**

  - **框架**: `Vue 3` (使用 Composition API)
  - **构建工具**: `Vite` - 提供极速的开发服务器和打包体验。
  - **UI 库**: `Element Plus` 或 `Ant Design Vue` - 快速构建美观、专业的界面。
  - **状态管理**: `Pinia` - Vue 3 官方推荐的状态管理库。
  - **HTTP 请求**: `Axios` - 成熟可靠的 HTTP 客户端。
  - **路由**: `Vue Router`

- **后端 (Backend)**

  - **框架**: `Spring Boot` - 快速构建健壮的 Java RESTful API。
  - **核心依赖**:
    - `Spring Web`: 用于构建 Web 应用和 RESTful API。
    - `Spring Security`: 处理用户认证和授权，可集成 JWT (JSON Web Token)。
    - `Spring Data JPA`: 简化数据库操作，与 Hibernate 配合使用。
    - `Lombok`: 减少样板代码（如 `getter`, `setter`）。
  - **构建工具**: `Maven` 或 `Gradle`。

- **数据库 (Database)**

  - **数据库**: `MySQL 8.0+`

- **AI 服务集成**
  - 后端通过 HTTP 客户端（如 `OkHttp` 或 `Spring WebClient`）调用各大 AI 厂商的官方 API。

---

## 4. 数据库表结构设计 (E-R)

### 4.1. `users` - 用户表

| 字段名           | 类型             | 约束       | 描述                              |
| :--------------- | :--------------- | :--------- | :-------------------------------- |
| `id`             | `BIGINT`         | 主键, 自增 | 用户唯一标识                      |
| `username`       | `VARCHAR(50)`    | 唯一, 非空 | 用户名                            |
| `password_hash`  | `VARCHAR(255)`   | 非空       | 加密后的密码                      |
| `email`          | `VARCHAR(100)`   | 唯一, 非空 | 邮箱                              |
| `credit_balance` | `DECIMAL(10, 4)` | 默认 0.00  | 用户积分余额                      |
| `is_admin`       | `TINYINT(1)`     | 默认 0     | 是否为管理员 (0: 普通用户, 1: 管理员) |
| `created_at`     | `DATETIME`       |            | 创建时间                          |
| `updated_at`     | `DATETIME`       |            | 更新时间                          |

### 4.2. `ai_models` - AI 模型表

| 字段                 | 类型             | 约束       | 描述                                    |
| :------------------- | :--------------- | :--------- | :-------------------------------------- |
| `id`                 | `INT`            | 主键, 自增 | 模型唯一标识                            |
| `model_name`         | `VARCHAR(100)`   | 非空       | 模型名称 (e.g., gpt-4, claude-3-sonnet) |
| `provider`           | `VARCHAR(50)`    | 非空       | 提供商 (e.g., OpenAI, Anthropic)        |
| `api_endpoint`       | `VARCHAR(255)`   | 非空       | 该模型的 API 调用地址                   |
| `cost_per_1k_tokens` | `DECIMAL(10, 6)` | 非空       | 每 1000 token 的成本（美元或积分）      |
| `is_enabled`         | `BOOLEAN`        | 默认 true  | 是否启用                                |

### 4.3. `conversations` - 会话表

| 字段名       | 类型           | 约束             | 描述                                  |
| :----------- | :------------- | :--------------- | :------------------------------------ |
| `id`         | `BIGINT`       | 主键, 自增       | 会话唯一标识                          |
| `user_id`    | `BIGINT`       | 外键 -> users.id | 所属用户                              |
| `title`      | `VARCHAR(255)` | 非空             | 会话标题 (可取第一次提问的前 30 个字) |
| `created_at` | `DATETIME`     |                  | 创建时间                              |

### 4.4. `messages` - 消息表

| 字段名            | 类型          | 约束                     | 描述                         |
| :---------------- | :------------ | :----------------------- | :--------------------------- |
| `id`              | `BIGINT`      | 主键, 自增               | 消息唯一标识                 |
| `conversation_id` | `BIGINT`      | 外键 -> conversations.id | 所属会话                     |
| `role`            | `VARCHAR(10)` | 非空                     | 角色 ('user' 或 'assistant') |
| `content`         | `TEXT`        | 非空                     | 消息内容                     |
| `model_id`        | `INT`         | 外键 -> ai_models.id     | 本次交互使用的模型           |
| `tokens_consumed` | `INT`         |                          | 本次交互消耗的 token 数      |
| `created_at`      | `DATETIME`    |                          | 创建时间                     |

---

## 5. 开发路线图 (Roadmap)

建议分阶段进行，逐步迭代。

### **阶段一：后端基础与核心 API**

1.  **项目初始化**: 创建 Spring Boot 项目，配置 Maven/Gradle，集成基础依赖。
2.  **数据库配置**: 连接 MySQL 数据库，使用 Flyway 或 Liquibase 管理数据库版本。
3.  **实体与表创建**: 创建上述四个核心实体类 (User, AiModel, Conversation, Message) 和对应的数据库表。
4.  **用户认证 API**:
    - 实现 `POST /api/auth/register` (注册)
    - 实现 `POST /api/auth/login` (登录)，成功后返回 JWT。
    - 配置 Spring Security 保护其他 API。
5.  **AI 代理服务**:
    - 创建一个 `AiProxyService`。
    - **关键**: 实现一个核心方法 `getResponse(userId, modelId, prompt)`。
    - 此方法内部逻辑：
      a. 检查用户积分是否足够。
      b. 从数据库读取 `ai_models` 表获取模型信息（API Endpoint, Key 等）。
      c. 调用外部 AI 服务商的 API。
      d. 获取返回结果，计算 token 消耗。
      e. **扣除用户积分**。
      f. 将问答记录存入 `conversations` 和 `messages` 表。
      g. 返回结果给前端。

### **阶段二：前端界面开发**

1.  **项目初始化**: 使用 Vite 创建 Vue 3 项目。
2.  **页面结构**:
    - 创建登录/注册页面。
    - 创建主界面布局（例如：左侧是会话列表，右侧是对话窗口）。
3.  **API 对接**:
    - 封装 Axios，配置请求拦截器，自动在请求头中添加 JWT。
    - 对接登录、注册 API。
4.  **对话功能实现**:
    - 实现聊天输入框和消息显示区域。
    - 调用后端的 AI 代理 API，并将结果渲染到界面。
    - 实现模型选择下拉框。

### **阶段三：功能完善与优化**

1.  **流式响应 (Streaming)**:
    - 后端 API 修改为支持 SSE (Server-Sent Events)。这能让前端实现打字机效果，极大提升用户体验。
    - 前端使用 `EventSource` API 来接收流式数据。
2.  **会话管理**:
    - 实现前端的创建、切换、删除会话功能，并与后端 API 同步。
3.  **用户中心**:
    - 开发简单的用户中心页面，展示积分余额等。
4.  **完善计费**:
    - 精确计算 token（需要研究不同模型的计费方式），确保计费准确。

### **阶段四：部署与迭代**

1.  **部署**:
    - 将 Spring Boot 应用打包成 JAR 文件。
    - 使用 Nginx 作为反向代理，部署前端静态文件和后端服务。
    - 可以考虑使用 Docker 进行容器化部署
2.  **后续迭代**:
    - 增加积分充值功能（对接支付平台）。
    - 增加更详细的后台管理功能。
    - 支持图片输入等多模态能力。

---

## 6. 关键挑战与注意事项

- **API Key 安全**:
  - **严禁**将 AI 服务商的 API Key 硬编码在代码或前端。
  - 必须存储在后端服务器的环境变量或安全的配置文件中，由后端统一调用。
- **成本控制**:
  - AI API 调用是昂贵的。在开发阶段，务必设置好请求限制和监控。
  - 为用户设置合理的积分和费率，防止滥用。
- **实时响应体验**:
  - 传统请求-响应模式会让用户等待很久。**强烈建议**在阶段三实现 SSE 流式响应。
- **统一不同 AI 服务商的 API 格式**:
  - 不同服务商的 API 请求体和响应体结构不同。后端需要设计一个适配器模式 (Adapter Pattern)，将不同服务商的 API 封装成统一的内部接口。
- **错误处理**:
  - 必须妥善处理外部 API 调用失败、超时、返回错误等情况，并向用户提供清晰的提示。

## 7. 项目分工表

| 角色职责                                            | 建议负责人 | 主要任务                                                                                                 |
| --------------------------------------------------- | ---------- | -------------------------------------------------------------------------------------------------------- |
| 项目负责人 & 全栈架构师<br>(Team Lead & Architect)  | 马南杰     | 作为组长，负责整体项目规划、技术决策、任务分配和进度跟踪。协调前后端，并解决关键技术难题。               |
| 核心后端开发<br>(Core Backend Developer)            | 顾鑫亮     | 负责 Spring Boot 项目搭建、数据库设计与实现 (JPA)、用户认证 (Spring Security) 和基础数据接口的开发。     |
| AI 代理与计费开发<br>(AI Proxy & Billing Developer) | 贾明宇     | 负责最核心的 AI 代理服务，包括调用外部 AI API、设计适配器、实现计费逻辑和后端的流式响应 (SSE)。          |
| 前端负责人 & 核心功能开发<br>(Frontend Lead)        | 刘斌       | 负责前端项目架构 (Vite + Vue 3)、状态管理 (Pinia)、主聊天界面的开发和前端流式响应 (EventSource) 的实现。 |
| 前端辅助页面开发<br>(Frontend Developer)            | 马臣       | 负责开发登录注册页、用户中心、后台管理等辅助页面，并与前端负责人协作完成组件开发和样式优化。             |
| 部署运维 & 质量保障<br>(DevOps & QA)                | 海瑞       | 负责数据库管理、项目 Docker 化、服务器部署 (Nginx)，并主导项目测试，保障 API Key 安全和产品质量。        |
